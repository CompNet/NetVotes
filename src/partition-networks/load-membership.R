#############################################################################################
# Loads membership vectors processed using external tools.
# 
# 01/2016 Vincent Labatut
#############################################################################################
source("src/define-constants.R")



#############################################################################################
# Loads the partition estimated by the external tools (their file format needs a specific
# conversion processing).
#
# f.name: the path and name of the file or folder to load (depends on the format).
# algo.name: code representing the concerned (external) partitioning algorithm.
# keep.tmp: whether or not to keep the original files generated by the algorithm.  
#
# returns: the corresponding partition as a membership vector.
#############################################################################################
load.external.partition <- function(f.name, algo.name, keep.tmp)
{	if(startsWith(algo.name,COMDET.ALGO.ILS) || startsWith(algo.name,COMDET.ALGO.GRASP))
		result <- load.mestrado.partition(f.name, algo.name, keep.tmp)
	
	else
	{	# TODO treat other external tools here
	}
	
	return(result)
}



#############################################################################################
# Loads the partition estimated by the mestrado tool.
# 
# part.folder: Main folder meant to contain the results of the partitioning approach.
# algo.name: code representing the concerned (external) partitioning algorithm.
# keep.tmp: whether or not to keep the original files generated by the algorithm.  
#
# returns: the corresponding partition as a membership vector.
#############################################################################################
load.mestrado.partition <- function(part.folder, algo.name, keep.tmp=TRUE)
{	# identify the latest folder
	net.fname <- paste0(SIGNED.FILE,".G")
	temp.folder <- file.path(part.folder, algo.name, net.fname)
	details <- file.info(list.dirs(temp.folder))
	if(nrow(details)==0)
		stop("load.mestrado.partition: No subfolder was found in folder \"", temp.folder ,"\", cannot load the partition.")
	details <- details[with(details, order(as.POSIXct(mtime))), ]
	temp.folders <- rownames(details)
	folder.name <- file.path(temp.folders[length(temp.folders)])
	
	# set up the file name
	tmp <- strsplit(x=algo.name, split="_", fixed=TRUE)[[1]]
	rcc.flag <- strsplit(x=tmp[1], split="-", fixed=TRUE)[[1]][2]
	if(rcc.flag=="RCC")
		file.name <- file.path(folder.name, "rcc-result.txt")
	else
		file.name <- file.path(folder.name, "cc-result.txt")
	
	# open and read the file
	tlog(14,"Trying to load file: \"",file.name,"\"")
	con <- file(file.name, "r")
	lines <- readLines(con)
	close(con)

	# process the file content
	i <- 4
	line <- lines[i]
	res <- list()
	while(line!="")
	{  # process current line
		#print(line)
		line <- strsplit(x=line, "[ ", fixed=TRUE)[[1]][2]
		line <- strsplit(x=line, " ]", fixed=TRUE)[[1]][1]
		nodes <- as.integer(strsplit(x=line," ", fixed=TRUE)[[1]]) + 1 # plus one because C++ starts counting from zero
		res[[length(res)+1]] <- nodes
		
		# process next line
		i <- i + 1
		line <- lines[i]      
	}
	
	# build the membership vector
	mx <- max(unlist(res))
	membership <- rep(NA,mx)
	for(i in 1:length(res))
	{  nodes <- res[[i]]
		membership[nodes] <- i 
	}
	
#	# record the partition using the internal format
#	write.table(x=membership, file=partition.file, row.names=FALSE, col.names=FALSE)
	# possibly remove the original algorithm files
	if(!keep.tmp)
		unlink(x=temp.folder, recursive=TRUE)
	
	return(membership)
}
